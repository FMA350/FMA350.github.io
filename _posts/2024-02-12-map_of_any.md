---
layout: post
title:  "Maps of any in cpp"
author: Francesco
categories: [ Development ]
tags: [ cpp, development ]
language: English
image: assets/images/maps.webp
description: ""
featured: true
hidden: false
comments: true
---

Amongst the additions and innovations that c++17 brought about, std::any is certainly a powerful one.
A while back I decided to leverage the class to create a powerful construct: a map of any.


## Requirements

> "a python map, in C++".


The requirements for the exercise could be expressed by the following:

1. The class had to be able to store any types: int, double, char[], std::string, user defined classes and so on.
2. The class had to be able to store N values in subsections of depth D, with N and D defined at runtime.
3. The class had to preserve the interface of a c++ map. In fact, a C++ map could be thought as a special case of the generic map.\
   
The easiest way to think about it is as "a python map, in C++".
Feel free to try to code this class yourself. It is a fun exercise, I assure you.

## False starts

> Variants cannot hold vectors, nor maps, nor class rerences, nor void * pointers from hell.

When I began coding a solution for this exercise, I stumbled upon a few false starts.

Initially, I was hoping I could resolve the exercise with variadic templates. Indeed, templates make for an elegant solution when we intend to use a class or function that holds the same functionality with a variety of types. But they are not magic: the compiler simply creates the specialized code for each class or function at compile time. A map of strings and T can only contain one type T, whatever T might be.
Additionally, we are required to define the depth of our class at compile time as well (a breach of the second requirement).

I then attempted to use another c++17 innovation: variants. Variants are special structures similar to unions (but bettert and safer). A variant can contain any type of primitives. A map of variants would thus help with the first requirement, allowing us to store ints and alongside strings for instance. But again, they would fail miserably with the second requirement. Variants cannot hold vectors, nor maps, nor class references, nor void * pointers from hell.


## std::any comes to the rescue

Enter std::any, a class that allows safe type-casting and can store <i> any type </i>.
Can we just get away with a map of any?

Not quite.

We need to be able to store values at arbitrary depths, which means we need to be able to create what looks like maps inside a map on the fly.
Finally we do not want for our class to simply retun std::any. The class should handle implicit conversions, so for instance:

`int my_value = anyObject["section"]["int var stored"]; `

the anyObject object should be smart enough to return an int. Finally, the interface must mimic a std::map.

## Solution

The solution consists in a user defined class (called Node in my Github example). This class contains a member called storage:

`std::map<std::string, std::any> storage` 

We overload the operator[] as our accessor. We will "consume" the accessors and always return a pointer to a Node. But first, we remember the key we used to access the element. This will become important in the setters and getters of values.
 There is only a special case, and that is, if the element we are looking for exists and can be cast to a shared_pointer of Node. If so we return it. Otherwise, we return the object itself ("this").

Now the kicker, the class must be able discern if we are setting a value:

`anyObject["section"]["value"] = 42;`

Or if we are getting one:

`int answer = anyObject["section"]["value"];`

To do so, we again overload the operator= and the templated operator T(). We can now assign or cast and return the requested value.
`void operator=(std::any value)`
`template<typename T> operator T()`

But which key to use? The most attentive will have noticed that no key is passed in with these operator.
Not to worry, we saved the last key that was passed in with the operator[]. We can fulfil our job.

## Notes and additions

The Solution section will soon be expanded with a more detailed explanation.
Additionally, I am planning on expanding the example with dynamic section creation, and the ability to use the class
as an iterator, thus truly fulfilling the promise of a map like interface.


You can find the unabridged code for this exercise [on my github](https://github.com/FMA350/code_examples/blob/master/map_of_any/map_of_any.cpp).